# Claude HUD - Complete Development Guide

Claude HUD is a cross-platform desktop application that serves as a dashboard for Claude Code. It displays project statistics, task tracking, plugin management, and global Claude Code configuration insights.

**Tech Stack:**
- **Frontend:** TypeScript + Vue 3 + Vite + Pinia (in root directory)
- **Backend:** Rust + Tauri 2.9.5 (in `src-tauri/`)
- **Build System:** pnpm (Node.js) + Cargo (Rust)
- **Platforms:** macOS, Windows, Linux

---

## Quick Start

### Prerequisites
- Node.js 18+ with pnpm
- Rust 1.77.2+ with Cargo
- macOS, Windows, or Linux

### Development Setup (Two Terminals)

**Terminal 1 - Frontend Dev Server** (from project root):
```bash
pnpm install           # First time only
pnpm dev              # Starts Vite dev server on http://localhost:5173
```

**Terminal 2 - Tauri Desktop App** (from `src-tauri/`):
```bash
cd src-tauri
cargo tauri dev       # Launches app, watches both frontend and backend
```

Both processes must be running. The app auto-connects to the frontend dev server.

---

## Commands Reference

### Frontend Commands (from root directory)

#### Development
```bash
pnpm dev              # Start Vite dev server with hot reload
pnpm preview          # Preview production build locally
```

#### Building
```bash
pnpm build            # Build frontend to dist/ (required before desktop build)
```

#### Quality & Testing
```bash
pnpm lint             # Run ESLint on TypeScript and Vue files
pnpm type-check       # Run TypeScript type checking
pnpm test             # Run unit tests (if configured)
pnpm test:watch       # Run tests in watch mode
```

### Backend Commands (from `src-tauri/` directory)

#### Development
```bash
cargo tauri dev       # Start Tauri dev server with auto-reload
cargo check           # Quick syntax check without building
cargo build           # Build debug binary
cargo build --release # Build optimized release binary
```

#### Building for Distribution
```bash
# First build frontend from root:
cd ..
pnpm build
cd src-tauri

# Then build desktop app:
cargo tauri build                           # Auto-detects platform
cargo tauri build --target aarch64-apple-darwin  # macOS Apple Silicon
cargo tauri build --target x86_64-apple-darwin   # macOS Intel
cargo tauri build --target x86_64-pc-windows-msvc # Windows
```

Built apps appear in `src-tauri/target/release/bundle/`.

#### Code Quality
```bash
cargo fmt             # Format code (required before commits)
cargo clippy -- -D warnings  # Lint with all warnings as errors
cargo test            # Run all unit tests
cargo test test_name  # Run specific test by name
cargo test -- --nocapture   # Show println! output
```

### Before Every Commit

```bash
# Frontend
pnpm lint
pnpm type-check

# Backend (from src-tauri/)
cargo fmt
cargo clippy -- -D warnings
cargo test
```

---

## Project Structure

```
claude-hud/
├── CLAUDE.md                    # Main development guide
├── package.json                 # Frontend dependencies & scripts
├── pnpm-lock.yaml               # Frontend lock file
├── tsconfig.json                # TypeScript configuration
├── vite.config.ts               # Vite bundler config
├── src/                         # Frontend source
│   ├── main.ts                  # Vue app entry point
│   ├── App.vue                  # Root component with routing
│   ├── components/              # Reusable UI components
│   │   └── *.vue               # Component files using Vue 3 Composition API
│   ├── views/                   # Page-level components
│   │   ├── Dashboard.vue
│   │   ├── Projects.vue
│   │   ├── Artifacts.vue
│   │   └── Settings.vue
│   ├── stores/                  # Pinia state management
│   │   ├── dashboard.ts
│   │   ├── projects.ts
│   │   ├── artifacts.ts
│   │   └── plugins.ts
│   └── assets/                  # Static files (images, fonts)
├── dist/                        # Built frontend (generated by pnpm build)
└── src-tauri/                   # Rust backend
    ├── src/
    │   ├── main.rs              # Minimal entry point (delegates to lib.rs)
    │   └── lib.rs               # Core backend (1745 lines - single file)
    ├── Cargo.toml               # Rust dependencies
    ├── Cargo.lock               # Dependency lock file
    ├── tauri.conf.json          # Tauri app configuration
    ├── build.rs                 # Build script
    ├── capabilities/            # Tauri security definitions
    └── icons/                   # App icons (multiple sizes/formats)
```

---

## Architecture Overview

### Frontend Architecture

**Technology Stack:**
- **Vue 3** - Reactive UI framework with Composition API
- **TypeScript** - Type-safe development
- **Vite** - Lightning-fast build tool
- **Pinia** - State management (replaces Vuex)
- **Tauri API** - IPC bridge to backend

**Data Flow:**
```
User Interaction → Vue Component → Pinia Store → Tauri IPC invoke()
→ Rust Handler → File System/Logic → JSON Response → Store Update → UI Re-render
```

**Component Architecture:**

1. **Presentational Components** (`src/components/`)
   - Stateless or minimal state
   - Accept data via props
   - Emit events to parents
   - Reusable across views

2. **Container Components** (`src/views/`)
   - One per major page/feature
   - Connect to Pinia stores
   - Fetch data via Tauri IPC
   - Orchestrate child components

3. **Stores** (`src/stores/`)
   - Pinia-based state management
   - One store per major feature
   - Actions handle async IPC calls
   - Cache results to prevent redundant calls

**Vue 3 Composition API Pattern:**

```typescript
<script setup lang="ts">
import { ref, computed } from 'vue'

interface Props {
  title: string
  count?: number
}

const props = withDefaults(defineProps<Props>(), {
  count: 0
})

const emit = defineEmits<{
  update: [value: number]
}>()

const localState = ref(0)
const computedValue = computed(() => props.count + localState.value)

const handleClick = () => {
  emit('update', localState.value + 1)
}
</script>

<template>
  <div>
    <h1>{{ title }}</h1>
    <p>{{ computedValue }}</p>
    <button @click="handleClick">Click</button>
  </div>
</template>

<style scoped>
/* Scoped styles */
</style>
```

**Key Principles:**
- Use `<script setup>` syntax with TypeScript
- Never use IIFEs in components
- Props and emits are strongly typed
- Use `computed()` for derived state
- Use `ref()` for reactive state
- All data fetching happens in store actions

### Backend Architecture

**Single-File Design:**
- All logic in `src-tauri/src/lib.rs` (1745 lines)
- Four conceptual layers:
  1. **Data Structures** (lines 10-152) - Rust types for domain concepts
  2. **Utilities** (lines 154-762) - Config, paths, file operations
  3. **Business Logic** (lines 763-1000) - Data discovery and aggregation
  4. **IPC Handlers** (lines 1000-1745) - Frontend API via `#[tauri::command]`

**Key Data Structures:**

- **GlobalConfig** - Claude Code settings and paths
- **Project** - Single project with stats and tasks
- **ProjectStats** - Token counts, model usage, timestamps
- **Task** - Session metadata
- **Plugin** - Plugin with artifact counts
- **Artifact** - Skill/command/agent metadata
- **HudConfig** - Pinned projects (persisted in `~/.claude/hud.json`)

**Core Subsystems:**

1. **Configuration & Paths** (lines 154-195)
   - `get_claude_dir()` - Resolves `~/.claude`
   - `load_hud_config()` / `save_hud_config()` - Pinned projects

2. **Statistics & Parsing** (lines 196-326)
   - `parse_stats_from_content()` - Extract tokens from JSONL via regex
   - `compute_project_stats()` - Intelligent mtime-based caching
   - Tracks input/output tokens, cache tokens, model usage

3. **Artifact Management** (lines 336-472)
   - `count_artifacts_in_dir()` - Count skills/commands/agents
   - `parse_frontmatter()` - Extract YAML from .md files
   - `collect_artifacts_from_dir()` - Gather artifact metadata

4. **Project Discovery** (lines 867-969)
   - `has_project_indicators()` - Detect project type by files
   - `build_project_from_path()` - Construct project object
   - `load_projects_internal()` - Load pinned projects

5. **Session Summarization** (lines 569-647)
   - `generate_session_summary_sync()` - Synchronous summary via Claude CLI
   - `start_background_summaries()` - Background thread-based generation
   - Caches in `~/.claude/hud-summaries.json`

6. **Tauri IPC Commands** (lines 769-1678)
   - `load_dashboard()` - Complete dashboard data
   - `load_projects()` - Pinned projects
   - `load_project_details()` - Project with tasks
   - `load_artifacts()` - Skills/commands/agents
   - `toggle_plugin()` - Enable/disable plugins
   - Plus 10+ more command handlers

**Error Handling:**
- All functions return `Result<T, String>` for Tauri compatibility
- Errors automatically propagate to frontend
- File operations gracefully degrade (return empty defaults)

**Serialization:**
- All structs use `#[derive(Serialize, Deserialize, Clone, Debug)]`
- Tauri handles JSON serialization automatically
- Field names must match TypeScript interfaces (use `#[serde(rename)]` if different)

**Threading & Background Tasks:**
- `std::thread::spawn()` for non-blocking work
- `app_handle.emit()` sends events to frontend
- Statistics computed eagerly (not lazy)
- Clone data before moving into thread closures

**File Operations:**
- Synchronous I/O via `std::fs` (acceptable for desktop)
- `walkdir` for directory traversal
- `regex` for JSONL pattern matching
- `dirs` crate for platform-specific paths

---

## Runtime Configuration

The app reads from `~/.claude/` directory:

```
~/.claude/
├── settings.json                  # Global Claude Code config
├── hud.json                       # HUD state: pinned projects
├── hud-stats-cache.json           # Cached token usage
├── hud-summaries.json             # Cached session summaries
├── hud-project-summaries.json     # Cached project overviews
├── projects/
│   └── {encoded-path}/            # Path encoding: /a/b → -a-b
│       ├── {session1}.jsonl       # Session data
│       └── {session2}.jsonl
├── plugins/
│   ├── installed_plugins.json
│   └── {plugin-id}/
│       ├── plugin.json
│       ├── skills/
│       ├── commands/
│       ├── agents/
│       └── hooks/
├── skills/                        # Global skills directory
├── commands/                      # Global commands directory
└── agents/                        # Global agents directory
```

**JSONL Session File Format:**

Each line is a JSON object:
```json
{
  "type": "user|assistant|summary",
  "message": { "content": "text or [{\"type\": \"text\", \"text\": \"...\"}]" },
  "model": "claude-opus-4-5-20251101",
  "input_tokens": 1234,
  "output_tokens": 5678,
  "cache_read_input_tokens": 0,
  "cache_creation_input_tokens": 0,
  "timestamp": "2025-01-05T12:34:56Z"
}
```

---

## Tauri IPC Communication

### Invoking Backend Commands from Frontend

```typescript
import { invoke } from '@tauri-apps/api/core'

// Simple call
const dashboard = await invoke('load_dashboard')

// With type safety
const projects = await invoke<Project[]>('load_projects')

// Error handling
try {
  const result = await invoke('command_name', { param: value })
} catch (error) {
  console.error('IPC Error:', error)
}
```

### Listening to Backend Events

```typescript
import { listen } from '@tauri-apps/api/event'

const unlisten = await listen('summary-ready', (event) => {
  console.log('Payload:', event.payload)
  // Update UI
})

// Clean up
unlisten()
```

### Common Backend Events

- `summary-ready` - Session summary generated
- `project-summary-ready` - Project overview generated

### Type Safety (Critical!)

**Frontend TypeScript interfaces must match Rust struct definitions:**

```typescript
// Frontend (src/stores/projects.ts)
interface Project {
  path: string
  name: string
  stats: ProjectStats
  tasks: Task[]
  lastActivity: string
}

// Backend (src-tauri/src/lib.rs)
#[derive(Serialize, Deserialize)]
pub struct Project {
    pub path: String,
    pub name: String,
    pub stats: ProjectStats,
    pub tasks: Vec<Task>,
    pub last_activity: String,
}
```

**Important:**
- Field names must match (case-sensitive)
- Use `#[serde(rename)]` in Rust if names differ
- `Option<T>` in Rust → `T | null` in TypeScript
- `Vec<T>` in Rust → `T[]` in TypeScript
- After changing backend structs, update frontend types!

---

## State Management (Pinia)

### Store Pattern

```typescript
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { invoke } from '@tauri-apps/api/core'

export const useProjectsStore = defineStore('projects', () => {
  // State
  const projects = ref<Project[]>([])
  const loading = ref(false)
  const error = ref<string | null>(null)

  // Getters
  const projectCount = computed(() => projects.value.length)

  // Actions
  const loadProjects = async () => {
    loading.value = true
    error.value = null
    try {
      projects.value = await invoke('load_projects')
    } catch (err) {
      error.value = String(err)
    } finally {
      loading.value = false
    }
  }

  const addProject = async (path: string) => {
    try {
      await invoke('add_project', { path })
      await loadProjects() // Refresh
    } catch (err) {
      error.value = String(err)
    }
  }

  return { projects, loading, error, projectCount, loadProjects, addProject }
})
```

### Component Usage

```typescript
<script setup lang="ts">
import { useProjectsStore } from '@/stores/projects'
import { onMounted } from 'vue'

const projectsStore = useProjectsStore()

onMounted(() => {
  projectsStore.loadProjects()
})
</script>

<template>
  <div v-if="projectsStore.loading">Loading...</div>
  <div v-else-if="projectsStore.error" class="error">{{ projectsStore.error }}</div>
  <div v-else>
    <p>Total projects: {{ projectsStore.projectCount }}</p>
    <ul>
      <li v-for="project in projectsStore.projects" :key="project.path">
        {{ project.name }}
      </li>
    </ul>
  </div>
</template>
```

### Caching Strategy

- Store results in state after successful IPC calls
- Check state before fetching (avoid redundant calls)
- Implement manual refresh actions when needed
- Use computed properties for derived state

---

## Build & Deployment

### Development Build

```bash
# Terminal 1: Frontend dev server
pnpm dev

# Terminal 2: Tauri app
cd src-tauri
cargo tauri dev
```

### Production Build

```bash
# Step 1: Build frontend (from root)
pnpm build
# Creates: dist/

# Step 2: Build desktop app (from src-tauri/)
cd src-tauri
cargo tauri build
# Creates: src-tauri/target/release/bundle/
```

**Output Bundles:**
- macOS: `.dmg` installer
- Windows: `.exe` installer or portable
- Linux: `.AppImage` or `.deb`

### Build for Specific Platforms

```bash
cargo tauri build --target aarch64-apple-darwin  # macOS Apple Silicon
cargo tauri build --target x86_64-apple-darwin   # macOS Intel
cargo tauri build --target x86_64-pc-windows-msvc # Windows
```

**Important:** Always run `pnpm build` before `cargo tauri build` to embed frontend files.

---

## Code Style & Conventions

### General Principles

- Prefer easy-to-read code over clever code
- Never use IIFEs in React components (not applicable; using Vue)
- No extraneous comments; code should be self-documenting
- Don't run dev server unless needed (you typically run it yourself)

### Frontend (TypeScript/Vue)

- Use Vue 3 Composition API (no Options API)
- Use `<script setup>` syntax
- Props and emits must be strongly typed
- Use `computed()` for derived state
- Use `ref()` for reactive state
- Import types, not values, when possible
- ESLint must pass before committing

### Backend (Rust)

- Run `cargo fmt` before every commit
- Run `cargo clippy -- -D warnings` to catch mistakes
- Use easy-to-read code over clever code
- No extraneous comments; code should be self-documenting
- All public functions should handle errors gracefully

---

## Common Development Scenarios

### Adding a New Dashboard Section

1. Create backend Tauri command in `src-tauri/src/lib.rs`
2. Add TypeScript interfaces matching the Rust types
3. Add Pinia store action in `src/stores/`
4. Create Vue component in `src/components/`
5. Create view component in `src/views/`
6. Add route in `src/App.vue` if needed
7. Run tests and linting

### Modifying Statistics Parsing

1. Update regex patterns in `parse_stats_from_content()` (src-tauri/src/lib.rs:196-255)
2. Test with actual JSONL files from `~/.claude/projects/{encoded-path}/`
3. Delete `~/.claude/hud-stats-cache.json` to force recomputation
4. Run `cargo test` to verify

### Adding Project Type Detection

1. Modify `has_project_indicators()` (src-tauri/src/lib.rs:867-888)
2. Add file/directory checks for new project type
3. Update suggested projects logic if needed
4. Test with various project structures

### Platform-Specific Changes

- File operations: `open` (macOS), `explorer` (Windows), `xdg-open` (Linux)
- Terminal: Warp integration via osascript (macOS only)
- Check `cfg!` macros and conditional compilation

---

## Testing

### Frontend Testing (if configured)

```bash
pnpm test              # Run all tests
pnpm test:watch       # Watch mode
pnpm test:coverage    # Coverage report
```

### Backend Testing

```bash
cargo test                            # Run all tests
cargo test test_parse_stats           # Run specific test
cargo test -- --nocapture             # Show println!
cargo test -- --test-threads=1        # Run sequentially
```

### Priority Test Areas

**Backend:**
- Stats parsing (regex extraction, token counting)
- Frontmatter parsing (YAML extraction)
- Path resolution and encoding
- Cache invalidation logic
- Project discovery

**Frontend:**
- Component rendering
- Store actions and state mutations
- Tauri IPC mocking
- Type safety

### Example Backend Test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_stats_basic() {
        let content = r#"{"input_tokens":100,"output_tokens":50,"model":"claude-opus","timestamp":"2025-01-05T12:00:00Z"}"#;
        let mut stats = ProjectStats::default();
        parse_stats_from_content(content, &mut stats);
        assert_eq!(stats.total_input_tokens, 100);
        assert_eq!(stats.total_output_tokens, 50);
    }
}
```

---

## Debugging & Troubleshooting

### Inspect Runtime Files

```bash
# View cached statistics
cat ~/.claude/hud-stats-cache.json | jq .

# View HUD configuration
cat ~/.claude/hud.json | jq .

# View plugin registry
cat ~/.claude/plugins/installed_plugins.json | jq .

# Validate JSON
cat ~/.claude/hud.json | jq . > /tmp/hud.json && mv /tmp/hud.json ~/.claude/hud.json
```

### Debug Regex Patterns

```bash
# Test stats parsing regex
echo '{"input_tokens":1234}' | rg 'input_tokens":(\d+)'

# Find projects with recent activity
find ~/.claude/projects -name "*.jsonl" -type f -mtime -7
```

### Enable Debug Logging

```bash
# Run with debug output
RUST_LOG=debug cargo tauri dev

# Watch log file (macOS)
tail -f ~/Library/Logs/Claude\ HUD/main.log
```

### Common Issues

**Cache is stale:**
- Delete: `rm ~/.claude/hud-stats-cache.json`
- Restart app

**Frontend/Backend type mismatch:**
- Verify TypeScript types match Rust structs exactly
- Field names must be case-sensitive
- Check for missing `#[serde(rename)]` annotations

**Path encoding issues:**
- Projects encoded as: `/Users/peter/Code` → `-Users-peter-Code`
- Paths with existing hyphens may be ambiguous
- `try_resolve_encoded_path()` handles reconstruction

**Regex not matching:**
- Test against actual JSONL files, not synthetic data
- One JSON object per line required
- Malformed JSON is silently skipped

---

## Key Dependencies

**Frontend (package.json):**
- `vue@3` - UI framework
- `typescript` - Type safety
- `vite` - Build tool
- `pinia` - State management
- `@tauri-apps/api` - IPC bridge
- `eslint` - Code linting

**Backend (Cargo.toml):**
- `tauri 2.9.5` - Desktop framework
- `serde/serde_json` - Serialization
- `regex 1.11` - Pattern matching
- `walkdir 2.5` - Directory traversal
- `dirs 6.0` - Platform paths
- `tauri-plugin-shell` - Execute commands
- `tauri-plugin-dialog` - File dialogs

---

## Performance Characteristics

- **Stats Computation:** O(number of JSONL files), cached by mtime
- **Project Load:** O(pinned projects count) - typically fast
- **Session Parsing:** O(session file size) via regex
- **Artifact Discovery:** O(directory depth) with early filtering
- **Summary Generation:** ~1-2 seconds per session via Claude CLI

For projects with >1000 session files, consider async refactoring.

---

## Important Architecture Notes

**Path Encoding:**
- `/` → `-` replacement (e.g., `/Users/peter/Code` → `-Users-peter-Code`)
- Lossy for paths with existing hyphens, but recoverable
- `try_resolve_encoded_path()` intelligently reconstructs paths

**Frontend/Backend Sync:**
- TypeScript types must match Rust struct definitions exactly
- Changes to data structures require frontend updates
- Mismatched field names cause serialization failures

**IPC Communication:**
- Frontend must always go through Tauri commands
- Never access file system directly from frontend
- All errors propagate to frontend as strings

**Caching Strategy:**
- Mtime-based cache invalidation
- Old cache entries are harmless
- Delete cache files to force recomputation

**Platform Support:**
- Code handles Windows, macOS (Intel/ARM), and Linux
- Platform-specific operations use conditional compilation
- Terminal launch (macOS only) uses osascript + Warp

---

## Next Steps

1. Read existing CLAUDE.md files in root and src-tauri/ for detailed subsystem information
2. Understand data flow: User Action → Component → Store → IPC → Backend → Response
3. Before committing: lint, type-check, format, and test
4. Consult backend CLAUDE.md for specific subsystem details (stats parsing, artifacts, etc.)
5. Consult frontend architecture for specific UI patterns and component examples
